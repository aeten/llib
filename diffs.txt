diff --git a/llib/file.c b/llib/file.c
index 751850b..edcbc48 100644
--- a/llib/file.c
+++ b/llib/file.c
@@ -7,6 +7,14 @@
 /****
 Extended file handling.
 
+Mostly wrappers around familar functions; `file_gets` is a `fgets` that strips the line feed;
+The other functions return a refcounted string, or array of strings (like with `file_getlines`)
+
+There are functions that work with parts of filenames which don't have the limitations and gotchas
+of the libc equivalents.
+
+Finally, `file_fopen` provides a file wrapper `FILE**`. It returns an actual error string if it fails,
+and disposing this file object will close the underlying stream.
 */
 
 #ifdef _WIN32
@@ -58,16 +66,6 @@ char *file_getline(FILE *f) {
     return str_new(buff);
 }
 
-/// old friend `fopen` with dignified suicide.
-FILE *fopen_or_die(const char *file, const char *mode) {
-    FILE *f = fopen(file,mode);
-    if (f == NULL) {
-        perror("fopen");
-        exit(1);
-    }
-    return f;
-}
-
 static int size_of_file(FILE *fp) {
     int sz = fseek(fp, 0L, SEEK_END);
     sz = ftell(fp);
@@ -88,12 +86,7 @@ int file_size(const char *file)
     return sz;
 }
 
-/// read the contents of a file.
-// If `text` is true, will also strip any \r\n at the end.
-char *file_read_all(const char *file, bool text) {
-    FILE *fp = fopen(file,text ? "r" : "rb");
-    if (! fp)
-        return NULL;
+static char* read_all(FILE *fp) {
     int sz = size_of_file(fp);
     char *res = str_new_size(sz);
     int nr = fread(res,1,sz,fp);
@@ -107,6 +100,15 @@ char *file_read_all(const char *file, bool text) {
     return res;
 }
 
+/// read the contents of a file.
+// If `text` is true, will also strip any \r\n at the end.
+char *file_read_all(const char *file, bool text) {
+    FILE *fp = fopen(file,text ? "r" : "rb");
+    if (! fp)
+        return NULL;
+    return read_all(fp);
+}
+
 typedef char *Str;
 
 /// all the files from a file.
@@ -116,12 +118,25 @@ char **file_getlines(FILE *f) {
     return (Str*)seq_array_ref(lines);
 }
 
+static FILE *popen_out(const char *cmd) {
+    char buff[MAX_PATH];
+    sprintf(buff,"%s 2>&1",cmd);
+    return popen(buff,"r");
+}
+
+/// output of a command as text.
+// Will capture stderr as well.
+char *file_command(const char *cmd) {
+    FILE *out = popen_out(cmd);
+    Str text = read_all(out);
+    pclose(out);
+    return text;
+}
+
 /// output of a command as lines.
 // Will capture stderr as well.
 char **file_command_lines(const char *cmd) {
-    char buff[MAX_PATH];
-    sprintf(buff,"%s 2>&1",cmd);
-    FILE *out = popen(buff,"r");
+    FILE *out = popen_out(cmd);
     Str *lines = file_getlines(out);
     pclose(out);
     return lines;
@@ -135,7 +150,7 @@ char **file_files_in_dir(const char *mask, int abs) {
     } else {
         sprintf(buff,"%s %s",DIR,mask);
     }
-    Str *lines = file_command_lines(buff);
+    Str *lines = file_command_lines(buff); //--->????
     if (array_len(lines) == 1 && strstr(lines[0],"No such file") != NULL) {
         obj_unref(lines);
         return NULL;
diff --git a/llib/file.h b/llib/file.h
index 6faae9a..7eb798d 100644
--- a/llib/file.h
+++ b/llib/file.h
@@ -1,3 +1,9 @@
+/*
+* llib little C library
+* BSD licence
+* Copyright Steve Donovan, 2013
+*/
+
 #ifndef __FILE_H
 #define __FILE_H
 #include <stdio.h>
@@ -6,10 +12,10 @@
 char *file_gets(FILE *f, char *buff, int bufsize);
 char *file_getline(FILE *f);
 char *file_read_all(const char *file, bool text);
-FILE *fopen_or_die(const char *file, const char *mode);
 FILE **file_fopen(const char *file, const char *how);
 int file_size(const char *file);
 char **file_getlines(FILE *f);
+char *file_command(const char *cmd);
 char **file_command_lines(const char *cmd);
 char **file_files_in_dir(const char *dirname, int abs);
 
diff --git a/llib/list.c b/llib/list.c
index 342e8e6..6d4ecdf 100644
--- a/llib/list.c
+++ b/llib/list.c
@@ -11,7 +11,7 @@ Doubly-linked lists.
 `ListEntry` nodes as the `data` field, or the objects themselves are nodes (declared with
 LIST_HEADER up front in the struct).
 
-The nodes of a container list are not ref-counted and are simply freed.
+oThe nodes of a container list are not ref-counted and are simply freed.
 The contained values may be ref-counted and will then be unref'd when the
 container is disposed.
 
diff --git a/llib/obj.c b/llib/obj.c
index 835d38d..fce4994 100644
--- a/llib/obj.c
+++ b/llib/obj.c
@@ -34,8 +34,7 @@ array can always be accessed with `*s`.
 
 #define MAX_PTRS 10000
 
-#define out(x) fprintf(stderr,"%s = %x\n",#x,(intptr)x);
-
+// number of created 'live' objects -- access with obj_kount()
 static int kount = 0;
 
 #ifdef LLIB_PTR_LIST
@@ -258,19 +257,18 @@ bool obj_is_instance(const void *P, const char *name) {
 // If they are arrays of refcounted objects, then
 // this has to unref those objects. For structs,
 // there may be an explicit destructor.
-
 static void obj_free_(ObjHeader *h, const void *P) {
     OTP t = obj_type_(h);
     if (h->is_array) { // arrays may be reference containers
         if (h->is_ref_container) {
-            void **arr = (void**)P;
-            for (int i = 0, n = h->_len; i < n; i++) {
+          void **arr = (void**)P;
+          for (int i = 0, n = h->_len; i < n; i++) {
                 obj_unref(arr[i]);
-            }
+          }
         }
     } else { // otherwise there may be a custom dispose operation for the type
         if (t->dtor)
-            t->dtor((void*)P);
+          t->dtor((void*)P);
     }
 
     remove_our_ptr(h);
@@ -309,6 +307,9 @@ void obj_incr_(const void *P) {
 void obj_unref(const void *P) {
     if (P == NULL) return;
     ObjHeader *h = obj_header_(P);
+#ifdef DEBUG
+    assert(our_ptr(h));
+#endif
     --(h->_ref);
     if (h->_ref == 0)
         obj_free_(h,P);
@@ -357,21 +358,30 @@ void obj_dump_types(bool all) {
     printf("+++\n");
 }
 
-void obj_type_name(void *P, char *buff) {
-    buff += sprintf(buff,"(%s*)",obj_type(P)->name);
+const char *obj_type_name(void *P) {
+    static char buff[256];
+    char *b = buff;
+    b += sprintf(buff,"(%s*)",obj_type(P)->name);
     if (obj_is_array(P))
-        sprintf(buff,"[%d]",array_len(P));
+        sprintf(b,"[%d]",array_len(P));
+    return buff;
+}
+
+void obj_dump_ptr(void *P) {
+    int c = obj_refcount(P);
+    if (c != -1)
+        printf("%p ref %d type %s\n",P,c,obj_type_name(P));
+    else
+        printf("not one of ours\n");
 }
 
 #ifdef LLIB_PTR_LIST
 void obj_dump_pointers() {
-    char name[128];
     printf("+++ llib objects\n");
     FOR(i,max_p) {
         if (our_ptrs[i] != NULL) {
             void *P = (void*)((ObjHeader*)our_ptrs[i] + 1);
-            obj_type_name(P,name);
-            printf("%p ref %d type %s\n",P,obj_refcount(P),name);
+            obj_dump_ptr(P);            
         }
     }
     printf("+++\n");
@@ -386,7 +396,6 @@ void obj_dump_all() {
 }
 #endif
 
-
 typedef unsigned char byte;
 
 //? allocates len+1 - ok?
diff --git a/llib/obj.h b/llib/obj.h
index 9879470..a81d0ae 100644
--- a/llib/obj.h
+++ b/llib/obj.h
@@ -163,6 +163,7 @@ void seq_add_str(void *sp, const char*p);
 void seq_resize(Seq *s, int nsz);
 void seq_remove(void *sp, int pos, int len);
 void seq_insert(void *sp, int pos, void *src, int sz);
+void seq_adda(void *sp, void *buff, int sz);
 void *seq_array_ref(void *sp);
 
 #endif
diff --git a/llib/seq.c b/llib/seq.c
index 09f86b2..3c37666 100644
--- a/llib/seq.c
+++ b/llib/seq.c
@@ -1,3 +1,9 @@
+/*
+* llib little C library
+* BSD licence
+* Copyright Steve Donovan, 2013
+*/
+
 #include <string.h>
 #include "obj.h"
 
@@ -21,6 +27,7 @@ static void insert_remove(void *sp, int pos, void *ins, int sz) {
 
     if (ins) {  // make some room!    
         seq_resize(s, on + sz);
+        P = (char*)s->arr;
     }
     
     pos *= mlen;
@@ -47,3 +54,16 @@ void seq_insert(void *sp, int pos, void *src, int sz) {
         insert_remove(sp,pos,src,sz);
 }
 
+void seq_adda(void *sp, void *buff, int sz) {
+    Seq *s = (Seq *)sp;
+    ObjHeader *pr = obj_header_(s->arr);
+    ObjType *t = obj_type_(pr);   
+    int la = pr->_len, mlem = t->mlem;
+    int lss = sz==-1 ? array_len(buff) : sz;
+    int lass = la + lss;
+    if (lass > s->cap) {
+        seq_resize(s,lass);
+    }
+    memcpy((char*)s->arr + la*mlem, buff, lss*mlem);
+    array_len(s->arr) = lass; 
+}
diff --git a/llib/str.c b/llib/str.c
index f671894..2b016ea 100644
--- a/llib/str.c
+++ b/llib/str.c
@@ -5,6 +5,13 @@
 */
 
 ////  string manipulation.
+//
+// When building up strings use a strbuf, which is a sequence of chars;
+// the actual string is always `*S` but use `strbuf_tostring(S)` to properly clean up and
+// dispose of the sequence.
+//
+// Then there are searching operations which return a boolean or integer index.
+//
 // @module str
 
 // for strtok_r
@@ -113,6 +120,27 @@ char *str_fmt(const char *fmt,...) {
     return str;
 }
 
+static const char *whitespace = " \t\r\n";
+
+/// trim a string in-inplace
+void str_trim(char *s) {
+    int sz = strspn(s,whitespace);
+    if (sz > 0)
+        memmove(s,s+sz,strlen(s)-sz+1);
+    char *p = s + strlen(s) - 1;
+    while (*p && strchr(whitespace,*p) != NULL)
+        --p;
+    *(p+1) = 0;
+}
+
+/// does a string only consist of blank characters?
+bool str_is_blank(const char *s) {
+    return strspn(s,whitespace) == strlen(s);
+}
+
+/// Finding things in strings.
+// @section finding
+
 /// find substring `sub` in the string.
 int str_findstr(const char *s, const char *sub) {
     const char *P = strstr(s,sub);
@@ -152,28 +180,6 @@ int str_find_first_not_of(const char *s, const char *ps) {
         return sz;
 }
 
-static const char *whitespace = " \t\r\n";
-
-/// trim a string in-inplace
-void str_trim(char *s) {
-    int sz = strspn(s,whitespace);
-    if (sz > 0)
-        memmove(s,s+sz,strlen(s)-sz+1);
-    char *p = s + strlen(s) - 1;
-    while (*p && strchr(whitespace,*p) != NULL)
-        --p;
-    *(p+1) = 0;
-}
-
-/// does a string only consist of blank characters?
-bool str_is_blank(const char *s) {
-    return strspn(s,whitespace) == strlen(s);
-}
-
-
-// " one "
-// sz = 1; srlen = 5. Move 5 chars, get "one "
-
 #ifdef _WIN32
 #ifdef _MSC_VER
 #define strtok_r strtok_s
@@ -251,7 +257,8 @@ char *str_concat(char **ss, const char *delim) {
 }
 
 // useful function for making quick arrays of strings.
-// Note that this is _not_ a refcounted array.
+// Note that this array is _not_ a ref container; the
+// string addresses are just copied over.
 char **str_strings(char *first,...) {
     va_list ap;
     char *S;
diff --git a/tests/lakefile b/tests/lakefile
index a611637..8b3895d 100644
--- a/tests/lakefile
+++ b/tests/lakefile
@@ -1,11 +1,14 @@
 libs = choose(MSVC,'llib_static','llib')
-local function test(f)
+function build(f)
     return c99.program{f,incdir='..',libdir='../llib',
 	libs=libs,defines=choose(DEBUG,'DEBUG')
-    }:run()
+    }
 end
+function test(f) return build(f):run() end
 if P then
-  default{ test(P) }
+  local prog = P..EXE_EXT
+  if path.exists(prog) then os.remove(prog) end
+  default{ build(P) }
   return
 end
 default {
diff --git a/tests/test-file.c b/tests/test-file.c
index 94e3257..49a4e7b 100644
--- a/tests/test-file.c
+++ b/tests/test-file.c
@@ -10,7 +10,7 @@ typedef char *Str;
 
 void reading_lines(Str file)
 {
-    FILE *f = fopen_or_die(file,"r");
+    FILE *f = fopen(file,"r");
     printf("size was %d bytes\n",file_size(file));
     Str *lines = file_getlines(f);
     printf("no of lines %d \n",array_len(lines));
diff --git a/tests/test-seq.c b/tests/test-seq.c
index dec3e9d..4a316c8 100644
--- a/tests/test-seq.c
+++ b/tests/test-seq.c
@@ -27,6 +27,8 @@ Foo *foo_new()
 
 #define DUMP(T,F,arr) FOR_ARR(T,p_,arr) \
     printf(F,*p_);  printf("\n");
+    
+typedef unsigned char byte;
 
 int main()
 {
@@ -39,6 +41,7 @@ int main()
     seq_add(fs, 50);
     FOR (i,22)
         seq_add(fs,i);
+    // seq is always pointer to the array
     printf("size %d \n",array_len(*fs));
     DUMP(int,"%d ",*fs);
     obj_unref(fs);
@@ -46,8 +49,23 @@ int main()
     double **ss = seq_new(double);
     seq_add(ss,1.0);
     seq_add(ss,2.0);
-    DUMP(double,"%f ",*ss)
-
+    // can append arrays
+    double *xx = array_new(double,2);
+    xx[0] = 3.0;
+    xx[1] = 4.0;
+    seq_adda(ss,xx,-1); // -> -1 means use array_len of xx
+    // and finally size-to-fit and extract the constructed array,
+    // deferencing the seq.
+    double *S = (double*)seq_array_ref(ss);
+    DUMP(double,"%f ",S);
+    
+    byte **bb = seq_new(byte);
+    byte b1[] = {10,20,30};
+    byte b2[] = {40,50,60};
+    seq_adda(bb,b1,3);
+    seq_adda(bb,b2,3);
+    DUMP(byte,"%d ",*bb);
+    
     // ref seqs are containers for ref objects
     typedef Foo *PFoo;
     PFoo **sf = seq_new_ref(PFoo);
